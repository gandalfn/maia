/* -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 4; tab-width: 4 -*- */
/*
 * core-event-args.hg
 * Copyright (C) Nicolas Bruguier 2010-2013 <gandalfn@club-internet.fr>
 *
 * maia is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * maia is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


#include <maia.h>
#include <maiamm/core-object.h>

_DEFS(maiamm,maia)
_PINCLUDE(maiamm/private/core-object_p.h)

#define MAIA_CORE_EVENT_ARGS_DEFINE(signature,klass)                   \
    static Glib::ObjectBase* wrap_new(GObject* object)                 \
    {                                                                  \
        return new klass ((MaiaCoreEventArgs*)object);                 \
    }                                                                  \
    klass () :                                                         \
        Glib::ObjectBase ("##klass##"),                                \
        Maia::Core::EventArgs (signature, & klass ::wrap_new)          \
    {                                                                  \
    }                                                                  \
    klass (MaiaCoreEventArgs* inpSelf) :                               \
        Glib::ObjectBase ("##klass##"),                                \
        Maia::Core::EventArgs (inpSelf)                                \
    {                                                                  \
    }

namespace Maia
{
    namespace Core
    {
        _GMMPROC_EXTRA_NAMESPACE(Core)

        class EventArgs : public Glib::Object
        {
            _CLASS_GOBJECT(EventArgs, MaiaCoreEventArgs, MAIA_CORE_EVENT_ARGS, Glib::Object, GObject)

            protected:
                EventArgs (const Glib::ustring& inSignature, Glib::WrapNewFunction inWrapFunc);

#m4 _CONVERSION(`Glib::VariantBase',`GVariant*',`g_variant_ref (($3).gobj())')
#m4 _CONVERSION(`GVariant*',`const Glib::VariantBase&',`Glib::wrap($3, true)')
#m4 _CONVERSION(`MaiaCoreEventArgs*', `const Glib::RefPtr<EventArgs>&', `Glib::wrap($3, true)')
                _WRAP_VFUNC(Glib::VariantBase serialize (), get_serialize)
                _WRAP_VFUNC(void unserialize (const Glib::VariantBase& inData), set_serialize, custom_vfunc_callback)
                _WRAP_VFUNC(void accumulate (const Glib::RefPtr<EventArgs>& inOther), accumulate)
#m4 _CONVERSION(`MaiaCoreEventArgs*', `const Glib::RefPtr<EventArgs>&', `Glib::wrap($3)')

                template<typename T>
                Glib::VariantBase serialize (T inVal);

                template<typename T, typename... Args>
                Glib::VariantBase serialize (T inVal, Args... inArgs);

                template<typename T>
                void unserialize (const Glib::VariantBase& inVariant, T& inVal);

                template<typename T, typename... Args>
                void unserialize (const Glib::VariantBase& inVariant, T& inVal, Args&... inArgs);

            public:
                _WRAP_METHOD(int get_sequence (), maia_core_event_args_get_sequence)
                _WRAP_METHOD(Glib::VariantBase get_serialize (), maia_core_event_args_get_serialize)
                _WRAP_METHOD(void set_serialize (const Glib::VariantBase& inData), maia_core_event_args_set_serialize)
                _WRAP_METHOD(void accumulate (const Glib::RefPtr<EventArgs>& inOther), maia_core_event_args_accumulate)
                _WRAP_METHOD(Glib::RefPtr<EventArgs> copy () const, maia_core_event_args_copy, refreturn)

                _WRAP_PROPERTY("sequence", int)
                _WRAP_PROPERTY("serialize", Glib::VariantBase)

            private:
                class SerializeClosure
                {
                    public:
                        enum class EContainerType
                        {
                            UNKNOWN,
                            BASIC,
                            TUPLE,
                            ARRAY
                        };

                    public:
                        SerializeClosure (const GVariantType* inType);
                        virtual ~SerializeClosure ();

                        Glib::VariantBase get ();
                        void set (const Glib::VariantBase& inVal);


                    private:
                        EContainerType                 m_ContainerType;
                        GVariantType*                  m_pType;
                        const GVariantType*            m_pCurrentType;
                        Glib::VariantBase              m_Variant;
                        std::vector<SerializeClosure*> m_Childs;
                };

                class UnserializeClosure
                {
                    public:
                        enum class EContainerType
                        {
                            UNKNOWN,
                            BASIC,
                            TUPLE,
                            ARRAY
                        };

                    public:
                        UnserializeClosure (const Glib::VariantBase& inVariant);
                        virtual ~UnserializeClosure ();

                        Glib::VariantBase get ();

                    private:
                        EContainerType                   m_ContainerType;
                        Glib::VariantBase                m_Variant;
                        std::vector<UnserializeClosure*> m_Childs;
                        int                              m_Index;
                };

                Glib::ustring       m_Signature;
                SerializeClosure*   m_pSerialize;
        };

        template<typename T>
        Glib::VariantBase EventArgs::serialize (T inVal)
        {
            if (!m_pSerialize)
            {
                m_pSerialize = new SerializeClosure (g_variant_type_new (m_Signature.c_str ()));
            }
            m_pSerialize->set (Glib::Variant<T>::create (inVal));

            Glib::VariantBase ret = m_pSerialize->get ();
            delete m_pSerialize; m_pSerialize = nullptr;

            return ret;
        }

        template<typename T, typename... Args>
        Glib::VariantBase EventArgs::serialize (T inVal, Args... inArgs)
        {
            if (!m_pSerialize)
            {
                m_pSerialize = new SerializeClosure (g_variant_type_new (m_Signature.c_str ()));
            }
            m_pSerialize->set (Glib::Variant<T>::create (inVal));

            return serialize (inArgs...);
        }

        template<typename T>
        void EventArgs::unserialize (const Glib::VariantBase& inVariant, T& inVal)
        {
            UnserializeClosure* pClosure = (UnserializeClosure*)steal_data ("Maia::Core::EventArgs::UnserializeClosure");
            if (!pClosure)
            {
                pClosure = new UnserializeClosure (inVariant);
            }
            Glib::VariantBase variant = pClosure->get ();

            delete pClosure; pClosure = nullptr;

            inVal = Glib::VariantBase::cast_dynamic< Glib::Variant<T> > (variant).get ();
        }

        template<typename T, typename... Args>
        void EventArgs::unserialize (const Glib::VariantBase& inVariant, T& inVal, Args&... inArgs)
        {
            UnserializeClosure* pClosure = (UnserializeClosure*)get_data ("Maia::Core::EventArgs::UnserializeClosure");
            if (!pClosure)
            {
                pClosure = new UnserializeClosure (inVariant);
                set_data ("Maia::Core::EventArgs::UnserializeClosure", (void*)pClosure);
            }

            Glib::VariantBase variant = pClosure->get ();
            inVal = Glib::VariantBase::cast_dynamic< Glib::Variant<T> > (variant).get ();

            unserialize (inVariant, inArgs...);
        }
    }
}
